/*
 * Copyright 2023 Signal Messenger, LLC
 * SPDX-License-Identifier: AGPL-3.0-only
 */

package org.signal.registration.sender.infobip.classic;

import com.google.i18n.phonenumbers.PhoneNumberUtil;
import com.google.i18n.phonenumbers.Phonenumber;
import com.google.protobuf.InvalidProtocolBufferException;
import com.infobip.ApiException;
import com.infobip.api.SmsApi;
import com.infobip.model.SmsAdvancedTextualRequest;
import com.infobip.model.SmsDestination;
import com.infobip.model.SmsResponse;
import com.infobip.model.SmsResponseDetails;
import com.infobip.model.SmsTextualMessage;
import io.micrometer.core.instrument.Timer;
import io.micronaut.scheduling.TaskExecutors;
import jakarta.inject.Named;
import jakarta.inject.Singleton;
import java.time.Duration;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import org.apache.commons.lang3.StringUtils;
import org.signal.registration.sender.ApiClientInstrumenter;
import org.signal.registration.sender.AttemptData;
import org.signal.registration.sender.ClientType;
import org.signal.registration.sender.MessageTransport;
import org.signal.registration.sender.SenderIdSelector;
import org.signal.registration.sender.SenderRejectedRequestException;
import org.signal.registration.sender.UnsupportedMessageTransportException;
import org.signal.registration.sender.VerificationCodeGenerator;
import org.signal.registration.sender.VerificationCodeSender;
import org.signal.registration.sender.VerificationSmsBodyProvider;
import org.signal.registration.sender.infobip.InfobipClassicSessionData;
import org.signal.registration.sender.infobip.InfobipExceptions;
import org.signal.registration.sender.infobip.InfobipSenderConfiguration;
import org.signal.registration.util.CompletionExceptions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.annotation.Nullable;

/**
 * Sends messages through the Infobip SMS API.
 * <p>
 * The <a href="https://www.infobip.com/docs/api/channels/sms/sms-messaging/outbound-sms">Infobip Outbound SMS API</a> sends arbitrary
 * SMS messages. Verification codes are generated by this class and added to the message text, then later verified
 * through the previously stored session.
 */
@Singleton
public class InfobipSmsSender implements VerificationCodeSender {
  private static final Logger logger = LoggerFactory.getLogger(InfobipSmsSender.class);

  private final InfobipSmsConfiguration configuration;
  private final Executor executor;
  private final VerificationCodeGenerator verificationCodeGenerator;
  private final VerificationSmsBodyProvider verificationSmsBodyProvider;
  private final SmsApi smsApiClient;
  private final ApiClientInstrumenter apiClientInstrumenter;
  private final SenderIdSelector senderIdSelector;
  public static final String SENDER_NAME = "infobip-sms";

  public InfobipSmsSender(
      final @Named(TaskExecutors.IO) Executor executor,
      final InfobipSmsConfiguration configuration,
      final VerificationCodeGenerator verificationCodeGenerator,
      final VerificationSmsBodyProvider verificationSmsBodyProvider,
      final SmsApi smsApiClient,
      final ApiClientInstrumenter apiClientInstrumenter,
      final InfobipSenderConfiguration senderConfiguration) {
    this.configuration = configuration;
    this.executor = executor;
    this.verificationCodeGenerator = verificationCodeGenerator;
    this.verificationSmsBodyProvider = verificationSmsBodyProvider;
    this.smsApiClient = smsApiClient;
    this.apiClientInstrumenter = apiClientInstrumenter;
    this.senderIdSelector = new SenderIdSelector(senderConfiguration.senderIdsByRegion(), senderConfiguration.defaultSenderId());
  }

  @Override
  public String getName() {
    return SENDER_NAME;
  }

  @Override
  public Duration getAttemptTtl() {
    return configuration.sessionTtl();
  }

  @Override
  public boolean supportsTransport(final MessageTransport transport) {
    return transport == MessageTransport.SMS;
  }

  @Override
  public boolean supportsLanguage(final MessageTransport messageTransport,
      final Phonenumber.PhoneNumber phoneNumber,
      final List<Locale.LanguageRange> languageRanges) {

    return verificationSmsBodyProvider.supportsLanguage(languageRanges);
  }

  @Override
  public CompletableFuture<AttemptData> sendVerificationCode(final MessageTransport messageTransport,
      final Phonenumber.PhoneNumber phoneNumber,
      final List<Locale.LanguageRange> languageRanges,
      final ClientType clientType) throws UnsupportedMessageTransportException {
    final String e164 = PhoneNumberUtil.getInstance().format(phoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164);

    final String verificationCode = verificationCodeGenerator.generateVerificationCode();
    final String body = verificationSmsBodyProvider.getVerificationBody(phoneNumber, clientType, verificationCode, languageRanges);

    final SmsTextualMessage smsMessage = new SmsTextualMessage()
        .from(senderIdSelector.getSenderId(phoneNumber))
        .addDestinationsItem(new SmsDestination().to(e164))
        .text(body);

    final SmsAdvancedTextualRequest smsMessageRequest = new SmsAdvancedTextualRequest()
        .messages(List.of(smsMessage));

    final Timer.Sample sample = Timer.start();

    return CompletableFuture.supplyAsync(() -> {
      try {
        final SmsResponse smsResponse = smsApiClient.sendSmsMessage(smsMessageRequest).execute();
        final String messageId = checkSenderRejectedAndExtractMessageId(smsResponse.getMessages());

        return new AttemptData(Optional.of(messageId),
            InfobipClassicSessionData.newBuilder()
                .setVerificationCode(verificationCode)
                .build().toByteArray());
      } catch (ApiException e) {
        logger.debug("Failed to send SMS message with {}, errors={}", e.getMessage(), e.details());
        throw CompletionExceptions.wrap(InfobipExceptions.toSenderException(e));
      } catch (SenderRejectedRequestException e) {
        logger.debug("Failed to send SMS message with {}", e.getMessage());
        throw CompletionExceptions.wrap(e);
      }
    }, this.executor)
    .whenComplete((ignored, throwable) ->
        apiClientInstrumenter.recordApiCallMetrics(
            getName(),
            "sms.create",
            throwable == null,
            throwable != null ? InfobipExceptions.getErrorCode(throwable) : null,
            sample));
  }

  private static String checkSenderRejectedAndExtractMessageId(@Nullable final List<SmsResponseDetails> responseDetailsList) throws SenderRejectedRequestException {
    if (responseDetailsList == null || responseDetailsList.isEmpty()) {
      logger.debug("No message response details for Infobip SMS attempt");
      throw new SenderRejectedRequestException("No message response details");
    }

    if (responseDetailsList.size() > 1) {
      logger.debug("More than one message response with message IDs {}", responseDetailsList.stream().map(SmsResponseDetails::getMessageId).toList());
    }

    final SmsResponseDetails finalResponseDetail = responseDetailsList.stream().filter(responseDetails-> responseDetails.getMessageId() != null)
        .findFirst()
        .orElseThrow(() -> new SenderRejectedRequestException("No SMS response with a message ID"));

    // Infobip enabled our account to return a 200 response with groupId 4 ("expired") or 5 ("rejected") in the response
    // body for a create SMS request, so we check for that and convert it into an exception.
    InfobipExceptions.maybeThrowSenderFraudBlockException(finalResponseDetail.getStatus());
    InfobipExceptions.maybeThrowInfobipRejectedRequestException(finalResponseDetail.getStatus());
    return finalResponseDetail.getMessageId();
  }

  @Override
  public CompletableFuture<Boolean> checkVerificationCode(String verificationCode, byte[] senderData) {
    try {
      final String storedVerificationCode = InfobipClassicSessionData.parseFrom(senderData).getVerificationCode();
      return CompletableFuture.completedFuture(StringUtils.equals(verificationCode, storedVerificationCode));
    } catch (final InvalidProtocolBufferException e) {
      logger.error("Failed to parse stored session data", e);
      return CompletableFuture.failedFuture(e);
    }
  }
}
